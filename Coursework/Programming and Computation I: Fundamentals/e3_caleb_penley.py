# -*- coding: utf-8 -*-
"""E3_Caleb_Penley.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12UJVjBvc6GAra8CN0BAzhsx6ujVhmKjT
"""

# 1.a
def func1():
  print("func1")

def func2():
  print("func2")

def func3():
  print("func3")

def complex_call():
  func2()
  func1()
  func1()
  func3()
  func1()
  func2()
  func1()
  func1()
  func2()
  func1()
  func1()
  func1()
  func2()
  func1()
  func1()

# 1.b - At the deepest level of the call stack, complex_call is the deepest, because it is the first function called in the stack.

#2
def bsearch_helper(lst, q, start, stop):
  if start > stop: # exit
    print("Not Found")
    return -1

  pivot = start + (stop - start) // 2

  if lst[pivot] == q:
    print("Found")
    return pivot
  elif lst[pivot] < q:
    print("Recursing Upper")
    return bsearch_helper(lst, q, pivot + 1, stop) #upper
  else:
    print("Recursing Lower")
    return bsearch_helper(lst, q, start, pivot - 1) #lower

def bsearch(lst, q):
  return bsearch_helper(lst, q, 0, len(lst) - 1)

#3

def harmonic_helper(runner):
  n = runner[0]
  iteration = runner[1]

  if n <= 0:
    value = 1
  elif n % 2 == 0:
    recurrent = harmonic_helper([n-5, iteration])
    value = n + recurrent[0]
    iteration = recurrent[1]
  else:
    recurrentUpper = harmonic_helper([n + 1, iteration])
    iteration = recurrentUpper[1]
    recurrentLower = harmonic_helper([n - 1, iteration])
    iteration = recurrentLower[1]
    value = recurrentUpper[0] / recurrentLower[0]
  return [value, iteration + 1]



def harmonic(n):
  output = harmonic_helper([n,-1])
  print("Value: ", output[0])
  print("Recursions: ", output[1])
def main():
  complex_call()
  print("\n")


  bsearch([1,4,6,7,8,12,15,27,28,29], 5)
  print("\n")

  harmonic(5.0)

if __name__ == '__main__':
    main()